;; NOTE: This namespace is generated by java-time.dev.gen
(ns java-time (:refer-clojure :exclude (zero? range iterate max min contains? format abs)) (:require java-time.clock java-time.util))
(let [lock (the-ns 'java-time) do-load (delay (locking lock (require 'java-time.adjuster 'java-time.amount 'java-time.chrono 'java-time.clock 'java-time.convert 'java-time.core 'java-time.format 'java-time.interval 'java-time.joda 'java-time.local 'java-time.pre-java8 'java-time.properties 'java-time.seqs 'java-time.single-field 'java-time.sugar 'java-time.temporal 'java-time.zone #?@(:bb [] :default ['java-time.mock]))))]
  (defn load-java-time "Load java-time implementation" [] @do-load))
(if *compile-files* (load-java-time) (when-not (= "true" (System/getProperty "java-time.no-async-load")) (.start (Thread. (fn [] (load-java-time))))))
(defmacro with-clock {:doc "Executes the given `forms` in the scope of the provided `clock`.\n\n  All the temporal entities that get created without parameters will inherit\n  their values from the clock:\n\n    (with-clock (system-clock \"Europe/London\")\n      (zone-id))\n    => #<java.time.ZoneRegion Europe/London>"} ([c & forms] (list* (quote java-time.clock/with-clock) c forms)))
(defmacro when-joda-time-loaded {:doc "Execute the `body` when Joda-Time classes are found on the classpath.\n\n  Take care - when AOT-compiling code using this macro, the Joda-Time classes\n  must be on the classpath at compile time!"} ([& body] (list* (quote java-time.util/when-joda-time-loaded) body)))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.clock/with-clock-fn))))] (defn with-clock-fn {:doc "Executes the given function in the scope of the provided clock. All the\n  temporal entities that get created without parameters will inherit their\n  values from the clock."} ([c f] ((deref +impl+) c f))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/zero?))))] (defn zero? {:doc "True if the amount is zero"} ([a] ((deref +impl+) a))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/negative?))))] (defn negative? {:doc "True if the amount is negative"} ([a] ((deref +impl+) a))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/negate))))] (defn negate {:doc "Negates a temporal amount:\n\n      (negate (negate x)) == x"} ([a] ((deref +impl+) a))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/abs))))] (defn abs {:doc "Returns the absolute value of a temporal amount:\n\n      (abs (negate x)) == (abs x)"} ([a] ((deref +impl+) a))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/max))))] (defn max {:doc "Latest/longest of the given time entities. Entities should be of the same\n  type"} ([o & os] (apply (deref +impl+) o os))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/min))))] (defn min {:doc "Earliest/shortest of the given time entities. Entities should be of the same\n  type"} ([o & os] (apply (deref +impl+) o os))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/before?))))] (defn before? {:doc "Returns a truthy value if time entities are ordered from the earliest to the\n  latest (same semantics as `<`):\n\n    (before? (local-date 2009) (local-date 2010) (local-date 2011))\n    => truthy...\n\n    (before? (interval (instant 10000) (instant 1000000))\n             (instant 99999999))\n    => truthy..."} ([x] ((deref +impl+) x)) ([x y] ((deref +impl+) x y)) ([x y & more] (apply (deref +impl+) x y more))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/not-after?))))] (defn not-after? {:doc "Similar to [[before?]], but also returns truthy if the inputs are equal."} ([x] ((deref +impl+) x)) ([x y] ((deref +impl+) x y)) ([x y & more] (apply (deref +impl+) x y more))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/after?))))] (defn after? {:doc "Returns a truthy value if time entities are ordered from the latest to the\n  earliest (same semantics as `>`):\n\n    (after? (local-date 2011) (local-date 2010) (local-date 2009))\n    => truthy...\n\n    (after? (instant 99999999)\n            (interval (instant 10000) (instant 1000000)))\n    => truthy..."} ([x] ((deref +impl+) x)) ([x y] ((deref +impl+) x y)) ([x y & more] (apply (deref +impl+) x y more))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/not-before?))))] (defn not-before? {:doc "Similar to [[after?]], but also returns truthy if the inputs are equal."} ([x] ((deref +impl+) x)) ([x y] ((deref +impl+) x y)) ([x y & more] (apply (deref +impl+) x y more))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/supports?))))] (defn supports? {:doc "True if the `o` entity supports the `p` property"} ([o p] ((deref +impl+) o p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/fields))))] (defn fields {:doc "Fields present in this temporal entity"} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/units))))] (defn units {:doc "Units present in this temporal entity."} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/properties))))] (defn properties {:doc "Map of properties present in this temporal entity"} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/property))))] (defn property {:doc "Property of this temporal entity under key `k`"} ([o k] ((deref +impl+) o k))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/as))))] (defn as {:doc "Values of property/unit identified by keys/objects `ks` of the temporal\n  entity `o`, e.g.\n\n    (as (duration 1 :hour) :minutes)\n    => 60\n\n    (as (local-date 2015 9) :year :month-of-year)\n    => [2015 9]"} ([o k] ((deref +impl+) o k)) ([o k1 k2] ((deref +impl+) o k1 k2)) ([o k1 k2 & ks] (apply (deref +impl+) o k1 k2 ks))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/value))))] (defn value {:doc "Value of the property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/range))))] (defn range {:doc "Range of values for this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/min-value))))] (defn min-value {:doc "Minimum value of this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/max-value))))] (defn max-value {:doc "Maximum value of this property, e.g. 29th of February for months"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/largest-min-value))))] (defn largest-min-value {:doc "Largest minimum value of this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/smallest-max-value))))] (defn smallest-max-value {:doc "Smallest maximum value of this property, e.g. 28th of February for months"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/truncate-to))))] (defn truncate-to {:doc "Truncates this entity to the specified time unit. Only works for units that\n    divide into the length of standard day without remainder (up to `:days`)."} ([o u] ((deref +impl+) o u))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/time-between))))] (defn time-between {:doc "Time between temporal entities `o` and `e` in unit `u`.\n\n      (j/time-between (j/local-date 2015) (j/local-date 2016) :days)\n      => 365\n\n      (j/time-between :days (j/local-date 2015) (j/local-date 2016))\n      => 365"} ([o e u] ((deref +impl+) o e u))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/with-zone))))] (defn with-zone {:doc "Returns this temporal entity with the specified `ZoneId`"} ([o z] ((deref +impl+) o z))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/plus))))] (defn plus {:doc "Adds all of the `os` to the time entity `o`. `plus` is not commutative, the\n  first argument is always the entity which will accumulate the rest of the\n  arguments.\n\n    (j/plus (j/local-date 2015) (j/years 1))\n    => <java.time.LocalDate \"2016-01-01\">"} ([o & os] (apply (deref +impl+) o os))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/minus))))] (defn minus {:doc "Subtracts all of the `os` from the time entity `o`\n\n    (j/minus (j/local-date 2015) (j/years 1))\n    => <java.time.LocalDate \"2014-01-01\">"} ([o & os] (apply (deref +impl+) o os))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/multiply-by))))] (defn multiply-by {:doc "Entity `o` multiplied by the value `v`"} ([o v] ((deref +impl+) o v))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/chronology))))] (defn chronology {:doc "The `Chronology` of the entity", :tag java.time.chrono.Chronology} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/leap?))))] (defn leap? {:doc "True if the year of this entity is a leap year."} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/with-value))))] (defn with-value {:doc "Underlying temporal entity with the value of this property set to `v`"} ([p v] ((deref +impl+) p v))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/with-min-value))))] (defn with-min-value {:doc "Underlying temporal entity with the value set to the minimum available for\n    this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/with-max-value))))] (defn with-max-value {:doc "Underlying temporal entity with the value set to the maximum\n    available for this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/with-largest-min-value))))] (defn with-largest-min-value {:doc "Underlying temporal entity with the value set to the largest minimum\n    available for this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.core/with-smallest-max-value))))] (defn with-smallest-max-value {:doc "Underlying temporal entity with the value set to the smallest maximum\n    available for this property"} ([p] ((deref +impl+) p))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/duration))))] (defn duration {:doc "Creates a duration - a temporal entity representing standard days, hours,\n  minutes, millis, micros and nanos. The duration itself contains only seconds\n  and nanos as properties.\n\n  Given one argument will\n    * interpret as millis if a number\n    * try to parse from the standard format if a string\n    * extract supported units from another `TemporalAmount`\n    * convert from a Joda Period/Duration\n\n  Given two arguments will\n    * get a duration between two `Temporal`s\n    * get a duration of a specified unit, e.g. `(duration 100 :seconds)`", :tag java.time.Duration} ([] ((deref +impl+))) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/period))))] (defn period {:doc "Creates a period - a temporal entity consisting of years, months and days.\n\n  Given one argument will\n    * interpret as years if a number\n    * try to parse from the standard format if a string\n    * extract supported units from another `TemporalAmount`\n    * convert from a Joda Period\n\n  Given two arguments will\n    * get a period of a specified unit, e.g. `(period 10 :months)`\n    * get a period between two temporals by converting them to local dates\n    * get a period of a specified number of years and months\n\n  Given three arguments will create a year/month/day period.", :tag java.time.Period} ([] ((deref +impl+))) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1)) ([arg__0 arg__1 arg__2] ((deref +impl+) arg__0 arg__1 arg__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/period?))))] (defn period? {:doc "True if an instance of java.time.Period."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/duration?))))] (defn duration? {:doc "True if an instance of java.time.Duration."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/nanos))))] (defn nanos {:doc "Duration of a specified number of nanos.", :tag java.time.Duration} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/micros))))] (defn micros {:doc "Duration of a specified number of microseconds.", :tag java.time.Duration} ([micros] ((deref +impl+) micros))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/millis))))] (defn millis {:doc "Duration of a specified number of millis.", :tag java.time.Duration} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/seconds))))] (defn seconds {:doc "Duration of a specified number of seconds.", :tag java.time.Duration} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/minutes))))] (defn minutes {:doc "Duration of a specified number of minutes.", :tag java.time.Duration} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/hours))))] (defn hours {:doc "Duration of a specified number of hours.", :tag java.time.Duration} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/standard-days))))] (defn standard-days {:doc "Duration of a specified number of days.", :tag java.time.Duration} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/days))))] (defn days {:tag java.time.Period} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/weeks))))] (defn weeks {:tag java.time.Period} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/months))))] (defn months {:tag java.time.Period} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.amount/years))))] (defn years {:tag java.time.Period} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.properties/unit?))))] (defn unit? {:doc "True if this is a `TemporalUnit`."} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.properties/unit))))] (defn unit {:doc "Returns a `TemporalUnit` for the given key `k` or extracts the field from\n  the given temporal `entity`.\n\n  You can see predefined units via `java-time.repl/show-units`.\n\n  If you want to make your own custom TemporalUnits resolvable, you need to rebind the\n  `java-time.properties/*units*` to a custom `java-time.properties.UnitGroup`.", :tag java.time.temporal.TemporalUnit} ([k] ((deref +impl+) k)) ([entity k] ((deref +impl+) entity k))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.properties/field?))))] (defn field? {:doc "True if this is a `TemporalField`."} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.properties/field))))] (defn field {:doc "Returns a `TemporalField` for the given key `k` or extracts the field from\n  the given temporal `entity`.\n\n  You can see predefined fields via `java-time.repl/show-fields`.\n\n  If you want to make your own custom TemporalFields resolvable, you need to rebind the\n  `java-time.properties/*fields*` to a custom `java-time.properties.FieldGroup`.", :tag java.time.temporal.TemporalUnit} ([k] ((deref +impl+) k)) ([entity k] ((deref +impl+) entity k))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.temporal/value-range))))] (defn value-range {:doc "Creates a `ValueRange` given the `min` and `max` amounts or a map of\n  `:min-smallest`, `:max-smallest`, `:min-largest` and `:max-largest`.", :tag java.time.temporal.ValueRange} ([min max] ((deref +impl+) min max)) ([arg0] ((deref +impl+) arg0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.temporal/instant))))] (defn instant {:doc "Creates an `Instant`. The following arguments are supported:\n\n    * no arguments - current instant\n    * one argument\n      + clock\n      + java.util.Date/Calendar\n      + another temporal entity\n      + string representation\n      + millis from epoch\n    * two arguments\n      + formatter (format) and a string", :tag java.time.Instant} ([] ((deref +impl+))) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.temporal/instant?))))] (defn instant? {:doc "True if an instance of java.time.Instant."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.local/local-date))))] (defn local-date {:doc "Creates a `LocalDate`. The following arguments are supported:\n\n    * no arguments - current local-date\n    * one argument\n      + clock\n      + another temporal entity\n      + string representation\n      + year\n    * two arguments\n      + formatter (format) and a string\n      + an instant and a zone id\n      + another temporal entity and an offset (preserves local time)\n      + year and month\n    * three arguments\n      + year, month and date", :tag java.time.LocalDate} ([] ((deref +impl+))) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1)) ([arg__0 arg__1 arg__2] ((deref +impl+) arg__0 arg__1 arg__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.local/local-date-time))))] (defn local-date-time {:doc "Creates a `LocalDateTime`. The following arguments are supported:\n\n    * no arguments - current local date-time\n    * one argument\n      + clock\n      + another temporal entity\n      + string representation\n      + year\n    * two arguments\n      + local date and local time\n      + an instant and a zone id\n      + formatter (format) and a string\n      + year and month\n\n    three and more arguments - year/month/day/...", :tag java.time.LocalDateTime} ([] ((deref +impl+))) ([y m d h] ((deref +impl+) y m d h)) ([y m d h mm] ((deref +impl+) y m d h mm)) ([y m d h mm ss] ((deref +impl+) y m d h mm ss)) ([y m d h mm ss n] ((deref +impl+) y m d h mm ss n)) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1)) ([arg__0 arg__1 arg__2] ((deref +impl+) arg__0 arg__1 arg__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.local/local-time))))] (defn local-time {:doc "Creates a `LocalTime`. The following arguments are supported:\n\n    * no arguments - current local time\n    * one argument\n      + clock\n      + another temporal entity\n      + string representation\n      + hours\n    * two arguments\n      + formatter (format) and a string\n      + an instant and a zone id\n      + hours and minutes\n    * three/four arguments - hour, minute, second, nanos", :tag java.time.LocalTime} ([] ((deref +impl+))) ([h m s nn] ((deref +impl+) h m s nn)) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1)) ([arg__0 arg__1 arg__2] ((deref +impl+) arg__0 arg__1 arg__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.local/local-date?))))] (defn local-date? {:doc "True if an instance of java.time.LocalDate."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.local/local-date-time?))))] (defn local-date-time? {:doc "True if an instance of java.time.LocalDateTime."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.local/local-time?))))] (defn local-time? {:doc "True if an instance of java.time.LocalTime."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/year))))] (defn year {:doc "Returns the `Year` for the given entity, string, clock, zone or number.\n Current year if no arguments given.", :tag java.time.Year} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/year?))))] (defn year? ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/month))))] (defn month {:doc "Returns the `Month` for the given month keyword name (e.g. `:january`),\n  ordinal or entity. Current month if no arguments given.", :tag java.time.Month} ([] ((deref +impl+))) ([v____auto__0] ((deref +impl+) v____auto__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/month?))))] (defn month? ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/day-of-week))))] (defn day-of-week {:doc "Returns the `DayOfWeek` for the given day keyword name (e.g. `:monday`),\n  ordinal or entity. Current day if no arguments given.", :tag java.time.DayOfWeek} ([] ((deref +impl+))) ([v____auto__0] ((deref +impl+) v____auto__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/day-of-week?))))] (defn day-of-week? ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/month-day))))] (defn month-day {:doc "Returns the `MonthDay` for the given entity, string, clock, zone or\n  month/day combination. Current month-day if no arguments given.", :tag java.time.MonthDay} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([a____auto__0 b____auto__1] ((deref +impl+) a____auto__0 b____auto__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/month-day?))))] (defn month-day? ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/year-month))))] (defn year-month {:doc "Returns the `YearMonth` for the given entity, string, clock, zone or\n  month/day combination. Current year-month if no arguments given.", :tag java.time.YearMonth} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([a____auto__0 b____auto__1] ((deref +impl+) a____auto__0 b____auto__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/year-month?))))] (defn year-month? ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/available-zone-ids))))] (defn available-zone-ids {:doc "Returns a set of string identifiers for all available ZoneIds."} ([] ((deref +impl+)))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/zone-id))))] (defn zone-id {:doc "Creates a `ZoneId` from a string identifier, `java.util.TimeZone` or extracts\n  from another temporal entity.\n\n  Returns default system zone id if no arguments provided.\n\n  Given two arguments will use the second as the offset.", :tag java.time.ZoneId} ([] ((deref +impl+))) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/zone-offset))))] (defn zone-offset {:doc "Creates a `ZoneOffset` from a string identifier (e.g. \"+01\"), a number of\n  hours/hours and minutes/hours, minutes and seconds or extracts from another\n  temporal entity.\n\n  Returns default system zone offset if no arguments provided.", :tag java.time.ZoneOffset} ([] ((deref +impl+))) ([o] ((deref +impl+) o)) ([h m] ((deref +impl+) h m)) ([h m s] ((deref +impl+) h m s))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/offset-date-time))))] (defn offset-date-time {:doc "Creates an `OffsetDateTime`. The following arguments are supported:\n\n    * no arguments - current date-time with the default offset\n    * one argument\n      + clock\n      + zone offset\n      + another temporal entity\n      + string representation\n      + year\n    * two arguments\n      + formatter (format) and a string\n      + local date-time and an offset\n      + another temporal entity and an offset (preserves local time)\n      + year and month\n    * three arguments\n      + local date, local time and an offset\n      + year, month and date\n    * four up to seven arguments - position date-time constructors\n    * eight arguments - time fields up to nanoseconds and a zone offset\n\n  If zone offset is not specified, default will be used. You can check the\n  default offset by invoking `(zone-offset)`.", :tag java.time.OffsetDateTime} ([] ((deref +impl+))) ([y m d h] ((deref +impl+) y m d h)) ([y mo d h m] ((deref +impl+) y mo d h m)) ([y mo d h m s] ((deref +impl+) y mo d h m s)) ([y mo d h m s n] ((deref +impl+) y mo d h m s n)) ([y mo d h m s n o] ((deref +impl+) y mo d h m s n o)) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1)) ([arg__0 arg__1 arg__2] ((deref +impl+) arg__0 arg__1 arg__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/offset-time))))] (defn offset-time {:doc "Creates an `OffsetTime`. The following arguments are supported:\n\n    * no arguments - current time with the default offset\n    * one argument\n      + clock\n      + zone id\n      + another temporal entity\n      + string representation\n      + hour\n    * two arguments\n      + formatter (format) and a string\n      + local time and an offset\n      + instant and an offset\n      + hour and minutes\n    * three arguments - hours, minutes, seconds\n    * four arguments - hours, minutes, seconds, nanos\n    * five arguments - last is the offset\n\n  If zone offset is not specified, default will be used. You can check the\n  default offset by invoking `(zone-offset)`.", :tag java.time.OffsetTime} ([] ((deref +impl+))) ([h m s] ((deref +impl+) h m s)) ([h m s n] ((deref +impl+) h m s n)) ([h m s n o] ((deref +impl+) h m s n o)) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/zoned-date-time))))] (defn zoned-date-time {:doc "Creates a `ZonedDateTime`. The following arguments are supported:\n\n    * no arguments - current date-time in the default zone\n    * one argument\n      + clock\n      + zone id\n      + another temporal entity\n      + string representation\n      + year\n    * two arguments\n      + formatter and a string\n      + local date-time and a zone id\n      + year and month\n    * three arguments\n      + local date, local time and a zone id\n      + year, month and day\n    * four to seven arguments - date-time fields\n    * eight arguments - last is the zone id\n\n  If zone id is not specified, default zone id will be used. You can check the\n  default zone by invoking `(zone-id)`.", :tag java.time.ZonedDateTime} ([] ((deref +impl+))) ([y m d h] ((deref +impl+) y m d h)) ([y mo d h m] ((deref +impl+) y mo d h m)) ([y mo d h m s] ((deref +impl+) y mo d h m s)) ([y mo d h m s n] ((deref +impl+) y mo d h m s n)) ([y mo d h m s n o] ((deref +impl+) y mo d h m s n o)) ([arg__0] ((deref +impl+) arg__0)) ([arg__0 arg__1] ((deref +impl+) arg__0 arg__1)) ([arg__0 arg__1 arg__2] ((deref +impl+) arg__0 arg__1 arg__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/system-clock))))] (defn system-clock {:doc "Creates a system clock. In the default timezone if called without arguments,\n  otherwise accepts a Zone Id.", :tag java.time.Clock} ([] ((deref +impl+))) ([k] ((deref +impl+) k))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/fixed-clock))))] (defn fixed-clock {:doc "Creates a fixed clock either at the current instant or at the supplied\n  instant/instant + zone.", :tag java.time.Clock} ([] ((deref +impl+))) ([i] ((deref +impl+) i)) ([i z] ((deref +impl+) i z))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/offset-clock))))] (defn offset-clock {:doc "Creates a clock offset from the current/provided clock by a given\n  `duration`.", :tag java.time.Clock} ([d] ((deref +impl+) d)) ([c d] ((deref +impl+) c d))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/tick-clock))))] (defn tick-clock {:doc "Creates a clock wrapping system/provided clock that only ticks as per\n  specified duration.", :tag java.time.Clock} ([d] ((deref +impl+) d)) ([c d] ((deref +impl+) c d))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/clock?))))] (defn clock? {:doc "Returns true if `x` is an instance of `java.time.Clock`."} ([x] ((deref +impl+) x))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/zone-id?))))] (defn zone-id? {:doc "True if an instance of java.time.ZoneId."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/zoned-date-time?))))] (defn zoned-date-time? {:doc "True if an instance of java.time.ZonedDateTime."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/offset-date-time?))))] (defn offset-date-time? {:doc "True if an instance of java.time.OffsetDateTime."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/offset-time?))))] (defn offset-time? {:doc "True if an instance of java.time.OffsetTime."} ([v____auto__0] ((deref +impl+) v____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/with-zone-same-instant))))] (defn with-zone-same-instant {:doc "Sets the zone to the specified value ensuring that the result has the same instant, e.g.:\n\n    (zoned-date-time 2015)\n    => #<java.time.ZonedDateTime 2015-01-01T00:00+00:00[Europe/London]>\n    (with-zone-same-instant *1 \"America/New_York\")\n    => #<java.time.ZonedDateTime 2014-12-31T18:00-05:00[America/New_York]>"} ([zdt z] ((deref +impl+) zdt z))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/with-offset))))] (defn with-offset {:doc "Sets the offset to the specified value ensuring that the local time stays\n    the same.\n\n      (offset-time 10 30 0 0 +2)\n      => #<java.time.OffsetTime 10:30+02:00>\n      (with-offset *1 +3)\n      => #<java.time.OffsetTime 10:30+03:00>"} ([o offset] ((deref +impl+) o offset))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.zone/with-offset-same-instant))))] (defn with-offset-same-instant {:doc "Sets the offset to the specified value ensuring that the result has the same instant, e.g.:\n\n      (offset-time 10 30 0 0 +2)\n      => #<java.time.OffsetTime 10:30+02:00>\n      (with-offset-same-instant *1 +3)\n      => #<java.time.OffsetTime 11:30+03:00>"} ([o offset] ((deref +impl+) o offset))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.mock/mock-clock))))] (defn mock-clock {:doc "Returns a mock implementation of the `java.time.Clock`. The mock supports\n  `advance-clock!` operation which allows to move the time in the clock, e.g.:\n\n  (let [clock (mock-clock 0 \"UTC\")]\n    (with-clock clock\n      (is (= (value clock) 0))\n      (is (= (instant) (instant 0)))\n      (advance-clock! clock (j/millis 1))\n      (is (= (value clock) 1))\n      (is (= (instant) (instant 1)))))\n\n  You can move the clock back via advancing by a negative temporal amount.\n\n  Creates a clock at epoch in the default timezone when called without arguments.", :tag java.time.Clock} ([] ((deref +impl+))) ([instant] ((deref +impl+) instant)) ([instant zone] ((deref +impl+) instant zone))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.mock/advance-clock!))))] (defn advance-clock! {:doc "Advances the `clock` by the given time `amount`.\n\n  This mutates the mock clock."} ([clock amount] ((deref +impl+) clock amount))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.mock/set-clock!))))] (defn set-clock! {:doc "Sets the `clock` to the given `time`.\n\n  This mutates the mock clock."} ([clock time] ((deref +impl+) clock time))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.convert/as-map))))] (defn as-map {:doc "Converts a time entity to a map of property key -> value as defined by the\n  passed in `value-fn`. By default the actual value of the unit/field is\n  produced.\n\n    (as-map (duration))\n    => {:nanos 0, :seconds 0}\n\n    (as-map (local-date 2015 1 1))\n    => {:year 2015, :month-of-year 1, :day-of-month 1, ...}"} ([e] ((deref +impl+) e)) ([e value-fn] ((deref +impl+) e value-fn))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.convert/convert-amount))))] (defn convert-amount {:doc "Converts an amount from one unit to another. Returns a map of:\n    * `:whole` - the whole part of the conversion in the `to` unit\n    * `:remainder` - the remainder in the `from` unit\n\n  Arguments may be keywords or instances of `TemporalUnit`.\n\n  Converts between precise units - nanos up to weeks, treating days as exact\n  multiples of 24 hours. Also converts between imprecise units - months up to\n  millenia. See `ChronoUnit` and `IsoFields` for all of the supported units.\n  Does not convert between precise and imprecise units.\n\n  Throws `ArithmeticException` if long overflow occurs during computation.\n\n    (convert-amount 10000 :seconds :hours)\n    => {:remainder 2800 :whole 2}"} ([amount from-unit to-unit] ((deref +impl+) amount from-unit to-unit))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.convert/to-java-date))))] (defn to-java-date {:deprecated true, :doc "Converts a date entity to a `java.util.Date`.\n\n  *Deprecated*:\n  This function only has a single arity and works for entities directly\n  convertible to `java.time.Instant`. Please consider using `java-date`\n  instead.", :tag java.util.Date} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.convert/to-sql-date))))] (defn to-sql-date {:deprecated true, :doc "Converts a local date entity to a `java.sql.Date`.\n\n  *Deprecated*:\n  This function only has a single arity and works for entities directly\n  convertible to `java.time.LocalDate`. Please consider using `sql-date`\n  instead.", :tag java.sql.Date} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.convert/to-sql-timestamp))))] (defn to-sql-timestamp {:deprecated true, :doc "Converts a date entity to a `java.sql.Timestamp`.\n\n  *Deprecated*:\n  This function only has a single arity and works for entities directly\n  convertible to `java.time.Instant`. Please consider using `sql-timestamp`\n  instead.", :tag java.sql.Timestamp} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.convert/to-millis-from-epoch))))] (defn to-millis-from-epoch {:doc "Converts a date entity to a `long` representing the number of milliseconds\n  from epoch."} ([o] ((deref +impl+) o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/monday?))))] (defn monday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a monday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/tuesday?))))] (defn tuesday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a tuesday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/wednesday?))))] (defn wednesday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a wednesday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/thursday?))))] (defn thursday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a thursday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/friday?))))] (defn friday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a friday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/saturday?))))] (defn saturday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a saturday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/sunday?))))] (defn sunday? {:doc "Returns true if the given time entity with the\n  `day-of-week` property falls on a sunday."} ([o____auto__0] ((deref +impl+) o____auto__0))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/weekend?))))] (defn weekend? ([dt] ((deref +impl+) dt))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.sugar/weekday?))))] (defn weekday? ([dt] ((deref +impl+) dt))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.seqs/iterate))))] (defn iterate {:doc "Returns a lazy sequence of `initial` , `(apply f initial v vs)`, etc.\n\n  Useful when you want to produce a sequence of temporal entities, for\n  example:\n\n    (iterate plus (days 0) 1)\n    => (#<Period P0D> #<Period P1D> #<Period P2D> ...)\n\n    (iterate plus (local-date 2010 1 1) (years 1))\n    => (#<LocalDate 2010-01-01> #<LocalDate 2011-01-01> ...)\n\n    (iterate adjust (local-date 2010 1 1) :next-working-day)\n    => (#<LocalDate 2010-01-01> #<LocalDate 2010-01-04> ...)"} ([f initial v & vs] (apply (deref +impl+) f initial v vs))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.adjuster/adjust))))] (defn adjust {:doc "Adjusts the temporal `entity` using the provided `adjuster` with optional `args`.\n\n  The adjuster should either be a keyword which resolves to one of the\n  predefined adjusters (see `java-time.repl/show-adjusters`) an instance of\n  `TemporalAdjuster` or a function which returns another temporal entity when\n  applied to the given one:\n\n    (adjust (local-date 2015 1 1) :next-working-day)\n    => #<LocalDate 2015-1-2>\n\n    (adjust (local-date 2015 1 1) :first-in-month :monday)\n    => #<LocalDate 2015-1-5>\n\n    (adjust (local-date 2015 1 1) plus (days 1))\n    => #<LocalDate 2015-1-2>"} ([entity adjuster & args] (apply (deref +impl+) entity adjuster args))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.format/format))))] (defn format {:doc "Formats the given time entity as a string.\n\n  Accepts something that can be converted to a `DateTimeFormatter` or a\n  formatter key, e.g. `:iso-offset-time`, as a first argument. Given one\n  argument uses the default format.\n\n    (format (zoned-date-time))\n    \"2015-03-21T09:22:46.677800+01:00[Europe/London]\"\n\n    (format :iso-date (zoned-date-time))\n    \"2015-03-21+01:00\""} ([o] ((deref +impl+) o)) ([fmt o] ((deref +impl+) fmt o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.format/formatter))))] (defn formatter {:doc "Constructs a DateTimeFormatter out of a\n\n  * format string - \"yyyy/MM/dd\", \"HH:mm\", etc.\n  * formatter name - :iso-date, :iso-time, etc.\n\n  Accepts a map of options as an optional second argument:\n\n  * `resolver-style` - either `:strict`, `:smart `or `:lenient`\n  * `case` - either `:insensitive` or `:sensitive` (defaults to :sensitive)", :tag java.time.format.DateTimeFormatter} ([fmt] ((deref +impl+) fmt)) ([fmt arg1] ((deref +impl+) fmt arg1))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.pre-java8/java-date))))] (defn java-date {:doc "Creates a `java.util.Date` out of any combination of arguments valid for\n  `java-time/instant` or the Instant itself.\n\n  A `java.util.Date` represents an instant in time. It's a direct analog of the\n  `java.time.Instant` type introduced in the JSR-310. Please consider using the\n  `java.time.Instant` (through `java-time/instant`) directly.", :tag java.util.Date} ([] ((deref +impl+))) ([a] ((deref +impl+) a)) ([a b] ((deref +impl+) a b))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.pre-java8/sql-date))))] (defn sql-date {:doc "Creates a `java.sql.Date` out of any combination of arguments valid for\n  `java-time/local-date` or the `LocalDate` itself.\n\n  Please consider using the JSR-310 Java Time types instead of `java.sql.Date`\n  if your drivers support them.\n\n  Even though `java.sql.Date` extends a `java.util.Date`, it's supposed to be\n  used as a local date (no time component or timezone) for the purposes of\n  conversion from/to native JDBC driver DATE types.", :tag java.sql.Date} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([G__0 G__1] ((deref +impl+) G__0 G__1)) ([G__0 G__1 G__2] ((deref +impl+) G__0 G__1 G__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.pre-java8/sql-timestamp))))] (defn sql-timestamp {:doc "Creates a `java.sql.Timestamp` in the local timezone out of any combination\n  of arguments valid for `java-time/local-date-time` or the `LocalDateTime`\n  itself.\n\n  The `sql-timestamp` constructor function does not support `Timestamp`\n  construction from an `Instant` or a long millis value. Please use\n  `instant->sql-timestamp` for this purpose.\n\n  Please consider using the JSR-310 Java Time types instead of\n  `java.sql.Timestamp` if your drivers support them.\n\n  `java.sql.Timestamp` is a version of a `java.util.Date` supposed to be used\n  as a local date-time (no timezone) for the purposes of conversion from/to native\n  JDBC driver TIMESTAMP types.", :tag java.sql.Timestamp} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([G__0 G__1] ((deref +impl+) G__0 G__1)) ([G__0 G__1 G__2] ((deref +impl+) G__0 G__1 G__2)) ([G__0 G__1 G__2 G__3] ((deref +impl+) G__0 G__1 G__2 G__3)) ([G__0 G__1 G__2 G__3 G__4] ((deref +impl+) G__0 G__1 G__2 G__3 G__4)) ([G__0 G__1 G__2 G__3 G__4 G__5] ((deref +impl+) G__0 G__1 G__2 G__3 G__4 G__5)) ([G__0 G__1 G__2 G__3 G__4 G__5 G__6] ((deref +impl+) G__0 G__1 G__2 G__3 G__4 G__5 G__6))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.pre-java8/instant->sql-timestamp))))] (defn instant->sql-timestamp {:doc "Creates a `java.sql.Timestamp` from the provided `instant-or-millis` - a\n  millisecond numeric time value or something convertible to an `Instant`.\n\n  Please consider using the JSR-310 Java Time types instead of\n  `java.sql.Timestamp` if your drivers support them.\n\n  `java.sql.Timestamp` is a version of a `java.util.Date` supposed to be used\n  as a local date-time (no timezone) for the purposes of conversion from/to native\n  JDBC driver TIMESTAMP types."} ([instant-or-millis] ((deref +impl+) instant-or-millis))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.pre-java8/sql-time))))] (defn sql-time {:doc "Creates a `java.sql.Time` out of any combination of arguments valid for\n    `java-time/local-time` (except the nanos constructor) or the `LocalTime`\n    itself.\n\n    Please consider using the JSR-310 Java Time types instead of `java.sql.Time`\n    if your drivers support them.\n\n    Even though `java.sql.Time` extends a `java.util.Date`, it's supposed to be\n    used as a local time (no date component or timezone) for the purposes of\n    conversion from/to native JDBC driver TIME types.", :tag java.sql.Time} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([G__0 G__1] ((deref +impl+) G__0 G__1)) ([G__0 G__1 G__2] ((deref +impl+) G__0 G__1 G__2))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/move-start-to))))] (defn move-start-to {:doc "Moves the start instant of the interval to the given instant (or something\n   convertible to an instant):\n\n   (move-start-to (interval 0 10000) (instant 5000))\n   => #<Interval ...:05Z/...:10Z>\n\n  Fails if the new start instant falls after the end instant:\n\n   (move-start-to (interval 0 10000) (millis 15000))\n   => DateTimeException..."} ([i new-start] ((deref +impl+) i new-start))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/move-end-to))))] (defn move-end-to {:doc "Moves the end of the interval to the given instant (or something\n   convertible to an instant):\n\n   (move-end-to (interval 0 10000) (instant 15000))\n   => #<Interval ...:00Z/...:15Z>\n\n  Fails if the new end instant falls before the start instant:\n\n   (move-end-to (interval 0 10000) (millis -1))\n   => DateTimeException..."} ([i new-end] ((deref +impl+) i new-end))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/move-start-by))))] (defn move-start-by {:doc "Moves the start instant of the interval by the sum of given\n  periods/durations/numbers of milliseconds:\n\n    (move-start-by (interval 0 10000) (millis 1000) (seconds 1))\n    => #<Interval ...:02Z/...:10Z>\n\n  Fails if the new start instant falls after the end instant.\n\n    (move-start-by (interval 0 10000) (millis 11000))\n    ; => DateTimeException..."} ([i & os] (apply (deref +impl+) i os))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/move-end-by))))] (defn move-end-by {:doc "Moves the end instant of the interval by the sum of given\n  periods/durations/numbers of milliseconds.\n\n    (move-start-by (interval 0 10000) (millis 1000) (seconds 1))\n    => #<Interval ...:00Z/...:12Z>\n\n  Fails if the new end instant falls before the start instant.\n\n    (move-end-by (interval 0 10000) (millis -11000))\n    => DateTimeException..."} ([i & os] (apply (deref +impl+) i os))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/start))))] (defn start {:doc "Gets the start instant of the interval"} ([i] ((deref +impl+) i))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/end))))] (defn end {:doc "Gets the end instant of the interval"} ([i] ((deref +impl+) i))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/contains?))))] (defn contains? {:doc "True if the interval contains the given instant or interval"} ([i o] ((deref +impl+) i o))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/overlaps?))))] (defn overlaps? {:doc "True if this interval overlaps the other one"} ([i oi] ((deref +impl+) i oi))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/abuts?))))] (defn abuts? {:doc "True if this interval abut with the other one"} ([i oi] ((deref +impl+) i oi))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/overlap))))] (defn overlap {:doc "Gets the overlap between this interval and the other one or `nil`"} ([i oi] ((deref +impl+) i oi))))
(let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/gap))))] (defn gap {:doc "Gets the gap between this interval and the other one or `nil`"} ([i oi] ((deref +impl+) i oi))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/interval))))] (defn interval {:doc "Constructs an interval out of a string, start and end instants or a start\n    + duration:\n\n    (j/interval \"2010-01-01T00:00:00Z/2013-01-01T00:00:00Z\")\n    => #<Interval 2010-01-01T00:00:00Z/2013-01-01T00:00:00Z>\n\n    (j/interval (j/instant 100000) (j/instant 1000000))\n    => #<Interval 1970-01-01T00:01:40Z/1970-01-01T00:16:40Z>\n\n    (j/interval (j/instant 100000) (j/duration 15 :minutes))\n    => #<Interval 1970-01-01T00:01:40Z/1970-01-01T00:16:40Z>\n\n    Requires the optional `threeten-extra` dependency.", :tag org.threeten.extra.Interval} ([o] ((deref +impl+) o)) ([a b] ((deref +impl+) a b)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.interval/interval?))))] (defn interval? {:doc "True if `Interval`"} ([o] ((deref +impl+) o)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/am-pm))))] (defn am-pm {:doc "Returns the `AmPm` for the given keyword name (`:am` or `:pm`),\n    ordinal or entity. Current AM/PM if no arguments given.", :tag org.threeten.extra.AmPm} ([] ((deref +impl+))) ([v____auto__0] ((deref +impl+) v____auto__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/am-pm?))))] (defn am-pm? ([o____auto__0] ((deref +impl+) o____auto__0)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/quarter))))] (defn quarter {:doc "Returns the `Quarter` for the given quarter keyword name (e.g. `:q1`),\n    ordinal or entity. Current quarter if no arguments given.", :tag org.threeten.extra.Quarter} ([] ((deref +impl+))) ([v____auto__0] ((deref +impl+) v____auto__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/quarter?))))] (defn quarter? ([o____auto__0] ((deref +impl+) o____auto__0)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/day-of-month))))] (defn day-of-month {:doc "Returns the `DayOfMonth` for the given entity, clock, zone or day of month.\n    Current day of month if no arguments given.", :tag org.threeten.extra.DayOfMonth} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/day-of-month?))))] (defn day-of-month? ([o____auto__0] ((deref +impl+) o____auto__0)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/day-of-year))))] (defn day-of-year {:doc "Returns the `DayOfYear` for the given entity, clock, zone or day of year.\n    Current day of year if no arguments given.", :tag org.threeten.extra.DayOfYear} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([fmt____auto__0 arg____auto__1] ((deref +impl+) fmt____auto__0 arg____auto__1)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/day-of-year?))))] (defn day-of-year? ([o____auto__0] ((deref +impl+) o____auto__0)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/year-quarter))))] (defn year-quarter {:doc "Returns the `YearQuarter` for the given entity, clock, zone or year with quarter.\n    Current year quarter if no arguments given.", :tag org.threeten.extra.YearQuarter} ([] ((deref +impl+))) ([G__0] ((deref +impl+) G__0)) ([a____auto__0 b____auto__1] ((deref +impl+) a____auto__0 b____auto__1)))))
(java-time.utils/when-threeten-extra (let [+impl+ (delay (load-java-time) (deref (resolve (quote java-time.single-field/year-quarter?))))] (defn year-quarter? ([o____auto__0] ((deref +impl+) o____auto__0)))))
